# Controllers (Local Planner)

In this exercise, you will visualize and understand how the **Nav2 Controller Server** and its default controller, the **Dynamic Window Based Controller (DWB)**, work.

## Basic Parameters

The **Nav2** Controller Server** has some plugins and configuration parameters that are independent of the controller used. Before we look at the controller specifics, let's go over some of the main parameters:

1. **General parameters**:

    ```use_sim_time```: Defines whether simulation time should be used

    ```controller_frequency```: Desired frequency of the controller

    ```min_(x/y/theta)_velocity_threshold```: Velocity threshold read by odometry to be sent to the controller. Values ​​below will be set to **0.0**

    ```progress_checker_plugin```: Name of the plugin used to evaluate the robot's progress (if it is moving)

    ```goal_checker_plugin```: Name of the plugin used to evaluate whether the robot has reached the goal (**Goal**)

    ```controller_plugins```: Name of the plugin containing the controller to be used

2. ```progress_checker```

    This plugin will be responsible for checking if the robot is moving.

    Its main parameters are:

    ```plugin```: **ROS2** plugin to be used

    ```required_movement_radius```: Minimum distance that the robot must move.

    ```movement_time_allowance```: Maximum time in which the robot must move the minimum distance to be considered moving.

3. ```goal_checker```

    This plugin is responsible for evaluating whether the robot has reached its goal.

    Its parameters are:

    ```plugin```: **ROS2** plugin to be used

    ```xy_goal_tolerance```: Minimum radius at which the robot must be in order for the position to be considered achieved.

    ```yaw_goal_tolerance```: Minimum angle difference that the robot must be in for the orientation to be considered achieved.

    ```stateful```: Indicates whether the plugin should check the position again after performing a rotation to align with the goal (which can cause small position movements).

### Exercise:

1. Start the **turtlebot3** simulation used in the last lessons. When loading, set the robot's initial position.

2. Send a navigation command and wait for the robot to reach the desired point. Pay attention to how close your robot got to the goal.

3. Stop the simulation and increase the values ​​of ```xy_goal_tolerance``` and ```yaw_goal_tolerance```. Repeat the previous steps and evaluate again how close the robot got to its goal.

4. Once again, change the values ​​of these parameters, but to very low values, close to zero. Now see if the robot is able to reach the goal.

5. Return the parameters to the original values ​​to continue to the next section.


## Dynamic Window Based (DWB)

Now let's take a closer look at some specific controller parameters and how they influence navigation.

By default, the parameters are defined in the ```FollowPath``` section, which is passed in the general ```controller_plugins``` parameter, but this name can be changed.

### Main Parameters:

```max_vel_x/max_vel_theta```: Defines the maximum linear and angular velocities. Since our robot is differential, the other velocities must be defined as **0.0**.

```acc_max_x/acc_max_theta```: Defines the maximum linear and angular accelerations. Prevents commands from exceeding the robot's physical capacity.

```vx_samples/vy_samples/vtheta_samples```: Number of samples in each dimension of the **velocity space**. The more samples, the better and more consistent the path will be, but it requires more processing.

```sim_time```: Time in advance that each sampled velocity will be extrapolated, generating a possible path.

```critics```: List of criticals to be used to calculate the final **cost** of each trajectory. The one with the lowest cost will be selected.

### Exercise:

1. Start the **turtlebot3** simulation used in the last classes. When loading, set the robot's initial position.

2. In the **rviz** sidebar, disable the visualization of the ```Amcl Particle Swarm```, ```Global Planner```, and, within ```Controller```, the ```Local Costmap```.

3. Send a navigation command. The path chosen by the **DWB** controller at each iteration should appear on a blue line that the robot must follow. It is possible to see small jumps in the trajectory between each controller loop; this happens because, as the controller works with a sampling of trajectories, the most optimized one will not always be available.

4. Now enable the visualization of the path generated by the **Planner** and send another navigation command. See the difference in route between the local and global planner, especially near curves.

5. Now stop the simulation and change the ```sim_time``` parameter in the configuration file to ```3.0```. Repeat the last steps and see how it influences route planning and navigation.

6. Return the ```sim_time``` parameter to its original value.

7. Now, reduce the number of samples in the ```vx_samples``` and ```vtheta_samples``` parameters. Run the simulation again and see what happens to the paths generated in each iteration.

8. Finally, extrapolate the parameters indicated in the previous item to higher values ​​and now evaluate the impact on navigation.


